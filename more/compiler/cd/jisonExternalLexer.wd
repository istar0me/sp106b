# 如何用 jison 寫一個 Ansi C 的 parser ?

在 jison 原始碼的 examples 資料夾當中，有一個標準的 Ansi C 語法檔 @[[ansic.jison]](code/ansic.jison) ，讓我們來試試看這個範例，以下是操作過程。

```
nqu-192-168-61-142:code mac020$ jison ansic.jison
nqu-192-168-61-142:code mac020$ node ansic.js test.c
/Users/mac020/Dropbox/cccwd/db/cd/code/ansic.js:100
    var lexer = Object.create(this.lexer);
                       ^

TypeError: Object prototype may only be an Object or null: undefined
    at Function.create (native)
    at Object.parse (/Users/mac020/Dropbox/cccwd/db/cd/code/ansic.js:100:24)
    at Object.commonjsMain [as main] (/Users/mac020/Dropbox/cccwd/db/cd/code/ansic.js:253:27)
    at Object.<anonymous> (/Users/mac020/Dropbox/cccwd/db/cd/code/ansic.js:256:11)
    at Module._compile (module.js:434:26)
    at Object.Module._extensions..js (module.js:452:10)
    at Module.load (module.js:355:32)
    at Function.Module._load (module.js:310:12)
    at Function.Module.runMain (module.js:475:10)
    at startup (node.js:117:18)
nqu-192-168-61-142:code mac020$ ls
ansic.jison	htmlparser.js	phraser.js	test.html
ansic.js	phraser.jison	test.c
nqu-192-168-61-142:code mac020$ 

```

您可以看到該檔案裏並沒有定義 lexer ，於是在執行時產生了失敗的情況。

那麼，我們應該怎麼加入 lexer 呢？

讓我們把產生的 ansic.js 程式拿出來看一看，會發現 parse 函數有下列的程式碼。

```
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
```

其中的 `var lexer = Object.create(this.lexer)` 這一行正是錯誤的所在。

觀察一下，您會發現我們需要為 ansic.Parser 定義一個 lexer 物件。

問題是，該怎麼定義呢？

繼續閱讀 ansic.js 程式碼，您會發現程式一開頭就告訴了你答案。

```
/* parser generated by jison 0.4.15 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
```

根據其中的 lexer 物件定義，我們必須要定義一個含有 parseError(), setInput(), input(), unput(), .... 等函數的 lexer ，才能讓程式開始動作。

當然，我們也可以不要自己定義這個 lexer 物件，只要我們在語法檔內補上 lexer 的語法就行了，以下是我為 ansic.jison 補上的 lexer 部分。

但是 lexer 該怎麼寫，我們可以參考 @[[calculator.jison]](code/calculator.jison) 與 [ANSI C grammar, Lex specification](http://www.lysator.liu.se/c/ANSI-C-grammar-l.html) 這兩個文件，然後加入下列段落到 ansic.jison 中，並且更名為 ansic_lex.jison 。

其完整的 jison 檔案如下：

檔案： @[[ansic_lex.jison]](code/ansic_lex.jison)

```
%token IDENTIFIER CONSTANT STRING_LITERAL SIZEOF
%token PTR_OP INC_OP DEC_OP LEFT_OP RIGHT_OP LE_OP GE_OP EQ_OP NE_OP
%token AND_OP OR_OP MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN
%token SUB_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN
%token XOR_ASSIGN OR_ASSIGN TYPE_NAME

%token TYPEDEF EXTERN STATIC AUTO REGISTER
%token CHAR SHORT INT LONG SIGNED UNSIGNED FLOAT DOUBLE CONST VOLATILE VOID
%token STRUCT UNION ENUM ELLIPSIS

%token CASE DEFAULT IF ELSE SWITCH WHILE DO FOR GOTO CONTINUE BREAK RETURN

%nonassoc IF_WITHOUT_ELSE
%nonassoc ELSE

/* lexical grammar */
%lex
%%

"typedef"               return 'TYPEDEF'
"extern"                return 'EXTERN'
"static"                return 'STATIC'
"auto"                  return 'AUTO'
"register"              return 'REGISTER'
"char"                  return 'CHAR'
"short"                 return 'SHORT'
"int"                   return 'INT'
"long"                  return 'LONG'
"signed"                return 'SIGNED'
"unsigned"              return 'UNSIGNED'
"float"                 return 'FLOAT'
"double"                return 'DOUBLE'
"const"                 return 'CONST'
"volatile"              return 'VOLATILE'
"void"                  return 'VOID'
"struct"                return 'STRUCT' 
"union"                 return 'UNION' 
"enum"                  return 'ENUM' 
"..."                   return 'ELLIPSIS'
"case"                  return 'CASE' 
"default"               return 'DEFAULT' 
"if"                    return 'IF' 
"else"                  return 'ELSE' 
"switch"                return 'SWITCH' 
"while"                 return 'WHILE' 
"do"                    return 'DO' 
"for"                   return 'FOR' 
"goto"                  return 'GOTO' 
"continue"              return 'CONTINUE' 
"break"                 return 'BREAK' 
"return"                return 'RETURN'
"sizeof"                return 'SIZEOF'

\s+                     /* skip whitespace */
[a-zA-Z]\w*             { return 'IDENTIFIER' }
L?\"(\\.|[^\\"])*\"     return 'STRING_LITERAL'
[0-9]+("."[0-9]+)?      return 'CONSTANT'
\w+                     return 'TYPE_NAME'

"->"                     return 'PTR_OP'
"++"                    return 'INC_OP'
"--"                    return 'DEC_OP'
"<<"                    return 'LEFT_OP'
">>"                    return 'RIGHT_OP'
"<="                    return 'LE_OP'
">="                    return 'GE_OP'
"=="                    return 'EQ_OP'
"!="                    return 'NE_OP'
"&&"                    return 'AND_OP'
"||"                    return 'OR_OP'
"*="                    return 'MUL_ASSIGN'
"/="                    return 'DIV_ASSIGN'
"%="                    return 'MOD_ASSIGN'
"+="                    return 'ADD_ASSIGN'
"-="                    return 'SUB_ASSIGN'
"<<="                   return 'LEFT_ASSIGN'
">>="                   return 'RIGHT_ASSIGN'
"&="                    return 'AND_ASSIGN'
"^="                    return 'XOR_ASSIGN'
"|="                    return 'OR_ASSIGN'
";"			            return ';'
"{"	         	return '{'
"}"		        return '}'
","			            return ','
":"			return ':'
"="			return '='
"("			return '('
")"			return ')'
"["      	return '['
"]"         return ']'
"."			return '.'
"&"			return '&'
"!"			return '!'
"~"			return '~'
"-"			return '-'
"+"			return '+'
"*"			return '*'
"/"			return '/'
"%"			return '%'
"<"			return '<'
">"			return '>'
"^"			return '^'
"|"			return '|'
"?"			return '?'
<<EOF>>                 return 'EOF'
.                       return 'INVALID'

/lex

%start translation_unit
%%

primary_expression
	: IDENTIFIER
	  { console.log($1); }
	| CONSTANT
	| STRING_LITERAL
	| '(' expression ')'
	;

postfix_expression
	: primary_expression
	| postfix_expression '[' expression ']'
	| postfix_expression '(' ')'
	| postfix_expression '(' argument_expression_list ')'
	| postfix_expression '.' IDENTIFIER
	| postfix_expression PTR_OP IDENTIFIER
	| postfix_expression INC_OP
	| postfix_expression DEC_OP
	;

argument_expression_list
	: assignment_expression
	| argument_expression_list ',' assignment_expression
	;

unary_expression
	: postfix_expression
	| INC_OP unary_expression
	| DEC_OP unary_expression
	| unary_operator cast_expression
	| SIZEOF unary_expression
	| SIZEOF '(' type_name ')'
	;

unary_operator
	: '&'
	| '*'
	| '+'
	| '-'
	| '~'
	| '!'
	;

cast_expression
	: unary_expression
	| '(' type_name ')' cast_expression
	;

multiplicative_expression
	: cast_expression
	| multiplicative_expression '*' cast_expression
	| multiplicative_expression '/' cast_expression
	| multiplicative_expression '%' cast_expression
	;

additive_expression
	: multiplicative_expression
	| additive_expression '+' multiplicative_expression
	| additive_expression '-' multiplicative_expression
	;

shift_expression
	: additive_expression
	| shift_expression LEFT_OP additive_expression
	| shift_expression RIGHT_OP additive_expression
	;

relational_expression
	: shift_expression
	| relational_expression '<' shift_expression
	| relational_expression '>' shift_expression
	| relational_expression LE_OP shift_expression
	| relational_expression GE_OP shift_expression
	;

equality_expression
	: relational_expression
	| equality_expression EQ_OP relational_expression
	| equality_expression NE_OP relational_expression
	;

and_expression
	: equality_expression
	| and_expression '&' equality_expression
	;

exclusive_or_expression
	: and_expression
	| exclusive_or_expression '^' and_expression
	;

inclusive_or_expression
	: exclusive_or_expression
	| inclusive_or_expression '|' exclusive_or_expression
	;

logical_and_expression
	: inclusive_or_expression
	| logical_and_expression AND_OP inclusive_or_expression
	;

logical_or_expression
	: logical_and_expression
	| logical_or_expression OR_OP logical_and_expression
	;

conditional_expression
	: logical_or_expression
	| logical_or_expression '?' expression ':' conditional_expression
	;

assignment_expression
	: conditional_expression
	| unary_expression assignment_operator assignment_expression
	;

assignment_operator
	: '='
	| MUL_ASSIGN
	| DIV_ASSIGN
	| MOD_ASSIGN
	| ADD_ASSIGN
	| SUB_ASSIGN
	| LEFT_ASSIGN
	| RIGHT_ASSIGN
	| AND_ASSIGN
	| XOR_ASSIGN
	| OR_ASSIGN
	;

expression
	: assignment_expression
	| expression ',' assignment_expression
	;

constant_expression
	: conditional_expression
	;

declaration
	: declaration_specifiers ';'
	| declaration_specifiers init_declarator_list ';'
	;

declaration_specifiers
	: storage_class_specifier
	| storage_class_specifier declaration_specifiers
	| type_specifier
	| type_specifier declaration_specifiers
	| type_qualifier
	| type_qualifier declaration_specifiers
	;

init_declarator_list
	: init_declarator
	| init_declarator_list ',' init_declarator
	;

init_declarator
	: declarator
	| declarator '=' initializer
	;

storage_class_specifier
	: TYPEDEF
	| EXTERN
	| STATIC
	| AUTO
	| REGISTER
	;

type_specifier
	: VOID
	| CHAR
	| SHORT
	| INT
	| LONG
	| FLOAT
	| DOUBLE
	| SIGNED
	| UNSIGNED
	| struct_or_union_specifier
	| enum_specifier
	| TYPE_NAME
	;

struct_or_union_specifier
	: struct_or_union IDENTIFIER '{' struct_declaration_list '}'
	| struct_or_union '{' struct_declaration_list '}'
	| struct_or_union IDENTIFIER
	;

struct_or_union
	: STRUCT
	| UNION
	;

struct_declaration_list
	: struct_declaration
	| struct_declaration_list struct_declaration
	;

struct_declaration
	: specifier_qualifier_list struct_declarator_list ';'
	;

specifier_qualifier_list
	: type_specifier specifier_qualifier_list
	| type_specifier
	| type_qualifier specifier_qualifier_list
	| type_qualifier
	;

struct_declarator_list
	: struct_declarator
	| struct_declarator_list ',' struct_declarator
	;

struct_declarator
	: declarator
	| ':' constant_expression
	| declarator ':' constant_expression
	;

enum_specifier
	: ENUM '{' enumerator_list '}'
	| ENUM IDENTIFIER '{' enumerator_list '}'
	| ENUM IDENTIFIER
	;

enumerator_list
	: enumerator
	| enumerator_list ',' enumerator
	;

enumerator
	: IDENTIFIER
	| IDENTIFIER '=' constant_expression
	;

type_qualifier
	: CONST
	| VOLATILE
	;

declarator
	: pointer direct_declarator
	| direct_declarator
	;

direct_declarator
	: IDENTIFIER
	| '(' declarator ')'
	| direct_declarator '[' constant_expression ']'
	| direct_declarator '[' ']'
	| direct_declarator '(' parameter_type_list ')'
	| direct_declarator '(' identifier_list ')'
	| direct_declarator '(' ')'
	;

pointer
	: '*'
	| '*' type_qualifier_list
	| '*' pointer
	| '*' type_qualifier_list pointer
	;

type_qualifier_list
	: type_qualifier
	| type_qualifier_list type_qualifier
	;


parameter_type_list
	: parameter_list
	| parameter_list ',' ELLIPSIS
	;

parameter_list
	: parameter_declaration
	| parameter_list ',' parameter_declaration
	;

parameter_declaration
	: declaration_specifiers declarator
	| declaration_specifiers abstract_declarator
	| declaration_specifiers
	;

identifier_list
	: IDENTIFIER
	| identifier_list ',' IDENTIFIER
	;

type_name
	: specifier_qualifier_list
	| specifier_qualifier_list abstract_declarator
	;

abstract_declarator
	: pointer
	| direct_abstract_declarator
	| pointer direct_abstract_declarator
	;

direct_abstract_declarator
	: '(' abstract_declarator ')'
	| '[' ']'
	| '[' constant_expression ']'
	| direct_abstract_declarator '[' ']'
	| direct_abstract_declarator '[' constant_expression ']'
	| '(' ')'
	| '(' parameter_type_list ')'
	| direct_abstract_declarator '(' ')'
	| direct_abstract_declarator '(' parameter_type_list ')'
	;

initializer
	: assignment_expression
	| '{' initializer_list '}'
	| '{' initializer_list ',' '}'
	;

initializer_list
	: initializer
	| initializer_list ',' initializer
	;

statement
	: labeled_statement
	| compound_statement
	| expression_statement
	| selection_statement
	| iteration_statement
	| jump_statement
	;

labeled_statement
	: IDENTIFIER ':' statement
	| CASE constant_expression ':' statement
	| DEFAULT ':' statement
	;

compound_statement
	: '{' '}'
	| '{' statement_list '}'
	| '{' declaration_list '}'
	| '{' declaration_list statement_list '}'
	;

declaration_list
	: declaration
	| declaration_list declaration
	;

statement_list
	: statement
	| statement_list statement
	;

expression_statement
	: ';'
	| expression ';'
	;

selection_statement
	: IF '(' expression ')' statement %prec IF_WITHOUT_ELSE
	| IF '(' expression ')' statement ELSE statement
	| SWITCH '(' expression ')' statement
	;

iteration_statement
	: WHILE '(' expression ')' statement
	| DO statement WHILE '(' expression ')' ';'
	| FOR '(' expression_statement expression_statement ')' statement
	| FOR '(' expression_statement expression_statement expression ')' statement
	;

jump_statement
	: GOTO IDENTIFIER ';'
	| CONTINUE ';'
	| BREAK ';'
	| RETURN ';'
	| RETURN expression ';'
	;

translation_unit
	: external_declaration EOF
	| translation_unit external_declaration
	;

external_declaration
	: function_definition
	| declaration
	;

function_definition
	: declaration_specifiers declarator declaration_list compound_statement
	| declaration_specifiers declarator compound_statement
	| declarator declaration_list compound_statement
	| declarator compound_statement
	;
	
```

注意其中的 `%start translation_unit` 這行代表起始的項目為 translation_unit。

接著用 `jison ansic_lex.jison` 指令再產生一次 Ansi C compiler ，就可以得到 ansic_lex.js 了。

為了測試我們的程式，我們寫了一個 test.c 程式如下：

```
int main() {
  char input[5];
  scanf("%s", input);
  printf("Your input : %s", input);
  return 1;
}
```

如果我們用 ansic_lex.js 來 compile 以下的 test.c 檔案，會得到下列結果。

```
nqu-192-168-61-142:code mac020$ node ansic_lex.js test.c
scanf
input
printf
input

```

於是我們成功的建立了一個 C 語言的 parser (應該不能說是 compiler 啦，還沒有編譯成機器碼或組合語言）。

